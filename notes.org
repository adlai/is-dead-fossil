
* Tasks

** TODO [#A] On first setup, the user has to (ql:quickload 'breeze)

Start by documenting how to start using breeze, then automate it.

** TODO Put these tasks in GitHub?

** TODO Advising swank-interactive-eval doesn't override emacs' repl
** TODO Advising swank-interactive-eval doesn't override sbcl's repl either
** TODO Document how to use breeze:defun

*** When redefining a function defined with breeze:defun, it run tests
*** When defining a test with breeze:deftest, it run tests

*** Demonstrate that the test-runner is debounced

When you redefine many function (e.g. when reloading a file), it
doens't run all the tests each time a something is redefined.


** TODO Document (with screenshots) how to setup and use emacs integration
** TODO Document how to use quickproject integration
** TODO Make the file-watcher usable
** TODO Document how to use the file-watcher
** TODO Document how the file-watcher works
** TODO There's no easy way to remove a test altogether
** TODO Add a condition "test-failed"

It can be used to *break-on-signals*
** TODO Optionnaly signal an error when a test fails

Currently, if we do that, we'll get 2 conditions if the evaluation
signals a condition and triggers test runs that fail.
** TODO Add binding to run test at point
** TODO Add command to choose a test and run it
** TODO [#B] When inserting a package definition in an empty buffer, evaluate the buffer :easy:
** TODO [#B] Use GitHub actions instead of TravisCI                     :ops:
** TODO [#C] Generate the documenation in the CI                    :ops:doc:
** TODO [#C] Add a link to the GitHub repository in the documentation :doc:ux:
** Add integration tests
*** TODO Look into emacs-director                                      :test:

https://github.com/bard/emacs-director

** TODO Try to detect when the current buffer/file was not loaded.

Could pass the file to br:next. What if
- it's a buffer that's not visiting a file?
- it's not a buffer in lisp-mode
- the buffer is empty
- the buffer requires some reader-macro
- the buffer is visiting a file, but there are unsaved modifications

** TODO Try to suggest new and old projects?

When the user just initialized breeze, try to find out if the user has
any lisp project(s) already opened, help him work on it.

If not projects are found guide him through (breeze-quickproject)

** TODO Suggest corrections when typos are detected

We already suggest stuff when there's, for example, an
undefined-function error. We could go one step further and suggest a
quickfix in the editor. We should probably suggest that quickfix only
when the edit-distance is not too great, or we would get some wild quickfixes.

* Design decisions

** Write everything in common lisp

As much as possible, so that breeze can easily be ported to different
platforms and editors.

** Wrap definitions

Decision: Create wrapper macros (e.g. =br:defun=) to keep the original
  forms for later analysis.

This decision is really not definitive.

This decision is less than ideal, especially for existing systems, but
it was the easiest to start with.

*** Alternatives

**** Keep the string being eval'd

Advising swank's eval function is "a good start" in that direction.

**** Parse the source code

Might be hard, but [[https://github.com/s-expressionists/Eclector][eclector]] could make this easy.

* Other projects with slime integration
** log4cl
* Portable file watching
https://www.reddit.com/r/lisp/comments/1iatcd/fswatcher_watches_filesystem_changes/

http://eradman.com/entrproject/

* Random ideas
** (tips), (tips "test"), (tips "doc")
** (next) ;; what's next? print functions that aren't done, that have no tests or documentation.
*** functions that aren't implemented or done
*** functions that have no tests
*** functions that have no documentation
*** Have a plain user-controlled task list
** Evaluate quality of documentation
*** e.g. if the documentation is almost just the name of the function
*** Make sure it doens't "only" refer to another function
*** It's more that the content of the function

(defun print-x (x)
  "print (* x x)"
  (print (* x x))

*** Make sure that all package have a :documentation
*** Make sure that all classes have a :documentation
** Evalutation the quality of the code
*** Cyclomatic complexity
*** Length of variable names
*** linting in general
** Compare the files in a system's directory and the actual components.
** See BIST to probalistically compare functions
*** Use a PRNG to generate inputs, use a hash to fingerprint the outputs
See [[file:scratch-files/function-fingerprinting.lisp][function-fingerprinting.lisp]]

** Generate test for existing functions

- The more we know the types of the expression, the more we can narrow
  down the search.
- It would be easier if we knew which expression are safe to execute

** Generate code based on desired input/output

https://github.com/webyrd/Barliman

- The more we know the types of the expression, the more we can narrow
  down the search.
- It would be easier if we knew which expression are safe to execute
- The linter can help choose better results
- Using e-graph to refactor candidates can help suggest helper
  functions


*** See Programming by examples (inductive synthesis)

** A lot of things could be done by instrumenting the code

Which is one of the reason behind wrapping the definitions (e.g. =breeze:defun=)

- fault injection
- program slicing
- Stepping though code
- profiling
- test coverage
- coverage guided
- profile-guided optimization

** Use equivalence-graph e-graph to suggest refactors

* See
** TODO uses of slime's locative: http://quickdocs.org/mgl-pax/
** TODO CCL's Watches https://ccl.clozure.com/manual/chapter4.12.html#watched-objects
** TODO CCL's Advise https://ccl.clozure.com/manual/chapter4.3.html#Advising
** TODO https://github.com/melisgl/mgl-pax for more emacs/slime integration
** TODO SLIMA for integration with Atom

Superior Lisp Interactive Mode for Atom

https://github.com/neil-lindquist/SLIMA

** TODO An implementation of the Language Server Protocol for Common Lisp

- https://github.com/cxxxr/cl-lsp
- related: https://marketplace.visualstudio.com/items?itemName=ailisp.commonlisp-vscode

** About e-graph

- https://egraphs-good.github.io/
- https://colab.research.google.com/drive/1tNOQijJqe5tw-Pk9iqd6HHb2abC5aRid?usp=sharing

* Libraries we might need in the future

** PROtocol and TESTcase manager

https://github.com/phoe/protest

** Concrete Syntax Tree

https://github.com/s-expressionists/Concrete-Syntax-Tree
This library is intended to solve the problem of source tracking for
Common Lisp code.

** SICL

A fresh implementation of Common Lisp
https://github.com/robert-strandh/SICL

I'm sure there are tons of other user-case:
- infer types
- interpret code (symbolically or not)

* Scratch files

Pieces of code that could be useful

#+begin_src lisp
(bordeaux-threads:destroy-thread
 (let ((current-thread (bt:current-thread)))
   (find-if #'(lambda (thread)
  		(and (not (eq current-thread thread))
  		     (string= "worker" (bt:thread-name thread))))
  	    (sb-thread:list-all-threads))))
#+end_src

* Prior Arts

** Tinker (1980)
http://web.media.mit.edu/%7Elieber/Lieberary/Tinker/Tinker/Tinker.html

** Image Based develoment

[Image based development](https://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/ibcl/index.html)
