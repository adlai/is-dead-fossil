
* Tasks

** TODO read-string should accept a default value

** TODO Basic commands should send the buffer

e.g. If the common-lisp side ask the editor to insert a string, but
the user changed buffer, the editor will insert the string in the
wrong buffer.

** TODO Rename breeze-swank to breeze-listener

We will want to support sly and probably other.

Also, most stuff in there is not "listener-specific".

** Showcase/demo                                                        :doc:

*** TODO Show the integration with quickproject

*** TODO Show how breeze can help create a project from a file

e.g. you made a "capture" with breeze, and now you want to turn that
into a project.

*** TODO Create a demo to show how to install breeze

*** TODO Create mock demos

This should help implementing the right thing.

** TODO Add command "go to next missing documentation"

** TODO Add command "got to next documentation"

To help revision

** TODO Add command "next todo"

Don't reimplement it, just figure out which how to configure the
editor to do that.

** TODO Use header-line in emacs to show the test results

Instead of a lighter

The lighter could still be used though, it could be a ✓ or χ.

** TODO Better explain what Breeze currently is in the readme           :doc:

As opposed to explain the principles, goals, non-goals, etc.

Actually explain what breeze *do*.

** TODO add a "What is this?" section                                   :doc:

** TODO [#A] On first setup, the user has to (ql:quickload 'breeze)      :ux:

Start by documenting how to start using breeze, then automate it.

** TODO Add links to all the "TODOs" in the documentation

grep TODO -h | to_github_url | to_html

** TODO It's too easy to kill the test-runner                       :impl:ux:

** TODO [#A] The test-runner's result interfere with swank normal usage :bug:

** TODO Breeze shouldn't suggest symbol that are "too far"

e.g not suggest "slot-exists-p" when trying to eval
"this-really-doesnt-exists".

*** TODO Make a "string distance" function that stops after a threshold

*** TODO Use a heap to find the N closest matches

Maybe look into VP-trees (Vantage-Point trees)

** TODO Advising swank-interactive-eval doesn't override emacs' repl   :impl:
** TODO Advising swank-interactive-eval doesn't override sbcl's repl either :impl:
** TODO Document how to use breeze:defun                                :doc:

*** When redefining a function defined with breeze:defun, it run tests
*** When defining a test with breeze:deftest, it run tests

*** Demonstrate that the test-runner is debounced

When you redefine many function (e.g. when reloading a file), it
doens't run all the tests each time a something is redefined.

** TODO Add link to github in the documentation                         :doc:

** TODO Document (with screenshots) how to setup and use emacs integration :doc:
** TODO Document how to use quickproject integration                    :doc:
** TODO Make the file-watcher usable                                   :impl:
** TODO Document how to use the file-watcher                            :doc:
** TODO Document how the file-watcher works                             :doc:
** TODO There's no easy way to remove a test altogether                  :ux:
** TODO Add a condition "test-failed"                                  :impl:

It can be used to *break-on-signals*
** TODO Optionnaly signal an error when a test fails                :impl:ux:

Currently, if we do that, we'll get 2 conditions if the evaluation
signals a condition and triggers test runs that fail.
** TODO Add binding to run test at point                                 :ux:
** TODO Add command to choose a test and run it                          :ux:
** TODO [#B] When inserting a package definition in an empty buffer, evaluate the buffer :easy:ux:
** DONE [#B] Use GitHub actions instead of TravisCI                     :ops:
** TODO Generate the documenation in the CI                         :ops:doc:

Really not a priority, even though generating the documentation
locally and commiting the result is less than ideal, it works well.

The main problem is that, AFAIK, you can't host something in github
pages without committing it into a repository. Which means that you
have to hack a CI pipeline that commit its results back into the
repository. This sucks.

An alternative would be to use GitLab pages, which are way more sane
as they allow (require, really) that your pages' content be generated
from the CI pipeline (from a job called "pages" to be exact). On the
other hand (again), I've had really janky load time with GitLab, but
that might just have been the Authentication + boatload of js.

** TODO [#C] Add a link to the GitHub repository in the documentation :doc:ux:
** Add integration tests
*** TODO Look into emacs-director                                      :test:

https://github.com/bard/emacs-director

** TODO Try to detect when the current buffer/file was not loaded (evaluated). :ux:

The goal would be to warn the user "hey, you're trying to evaluate
that function, but the package declared in this file/buffer doesn't
exists".

Could pass the file to br:next. What if
- it's a buffer that's not visiting a file?
- it's not a buffer in lisp-mode
- the buffer is empty
- the buffer requires some reader-macro
- the buffer is visiting a file, but there are unsaved modifications

** TODO Try to suggest new and old projects?                             :ux:

When the user just initialized breeze, try to find out if the user has
any lisp project(s) already opened, help him work on it.

If not projects are found guide him through (breeze-quickproject)

** TODO Suggest corrections when typos are detected                      :ux:

We already suggest stuff when there's, for example, an
undefined-function error. We could go one step further and suggest a
quickfix in the editor. We should probably suggest that quickfix only
when the edit-distance is not too great, or we would get some wild quickfixes.

** TODO Maybe add this document (notes.org) to the documentation?       :doc:

** TODO Maybe split the documentaion in multiple pages                  :doc:

** Commands

*** wrap with

**** TODO let

**** TODO multiple-value-bind

*** TODO add import-from

already has a prototype in emacs lisp

*** TODO move-form-into-let

already has a prototype in emacs lisp

*** TODO Comment current form

*** TODO Move top-level form up/down

** Follow up on issues

*** TODO https://github.com/slime/slime/issues/645

* Design decisions

** Write everything in common lisp

As much as possible, so that breeze can easily be ported to different
platforms and editors.

** Wrap definitions

Decision: Create wrapper macros (e.g. =br:defun=) to keep the original
  forms for later analysis.

This decision is really not definitive.

This decision is less than ideal, especially for existing systems, but
it was the easiest to start with.

*** Alternatives

**** Keep the string being eval'd

Advising swank's eval function is "a good start" in that direction.

**** Parse the source code

- Might be hard, but [[https://github.com/s-expressionists/Eclector][eclector]] could make this easy.
- [[https://github.com/hyotang666/read-as-string][hyotang666/read-as-string]] is another candidate

* Other projects with slime integration
** log4cl
* Portable file watching
https://www.reddit.com/r/lisp/comments/1iatcd/fswatcher_watches_filesystem_changes/

http://eradman.com/entrproject/
* Random ideas
** (tips), (tips "test"), (tips "doc")
** (next) ;; what's next? print functions that aren't done, that have no tests or documentation.
*** functions that aren't implemented or done
*** functions that have no tests
*** functions that have no documentation
*** Have a plain user-controlled task list
** Evaluate quality of documentation
*** e.g. if the documentation is almost just the name of the function
*** Make sure it doens't "only" refer to another function
*** It's more that the content of the function

(defun print-x (x)
  "print (* x x)"
  (print (* x x))

*** Make sure that all package have a :documentation
*** Make sure that all classes have a :documentation
** Evalutation the quality of the code
*** Cyclomatic complexity
*** Length of variable names
*** linting in general
** Compare the files in a system's directory and the actual components.
** See BIST to probalistically compare functions
*** Use a PRNG to generate inputs, use a hash to fingerprint the outputs
See [[file:scratch-files/function-fingerprinting.lisp][function-fingerprinting.lisp]]

** Generate test for existing functions

- The more we know the types of the expression, the more we can narrow
  down the search.
- It would be easier if we knew which expression are safe to execute

** Generate code based on desired input/output

https://github.com/webyrd/Barliman

- The more we know the types of the expression, the more we can narrow
  down the search.
- It would be easier if we knew which expression are safe to execute
- The linter can help choose better results
- Using e-graph to refactor candidates can help suggest helper
  functions


*** See Programming by examples (inductive synthesis)

** A lot of things could be done by instrumenting the code

Which is one of the reason behind wrapping the definitions (e.g. =breeze:defun=)

- fault injection
- program slicing
- Stepping though code
- profiling
- test coverage
- coverage guided
- profile-guided optimization

** Use equivalence-graph e-graph to suggest refactors

* See
** TODO uses of slime's locative: http://quickdocs.org/mgl-pax/
** TODO CCL's Watches https://ccl.clozure.com/manual/chapter4.12.html#watched-objects
** TODO CCL's Advise https://ccl.clozure.com/manual/chapter4.3.html#Advising
** TODO https://github.com/melisgl/mgl-pax for more emacs/slime integration
** TODO SLIMA for integration with Atom

Superior Lisp Interactive Mode for Atom

https://github.com/neil-lindquist/SLIMA

** TODO An implementation of the Language Server Protocol for Common Lisp

- https://github.com/cxxxr/cl-lsp
- related: https://marketplace.visualstudio.com/items?itemName=ailisp.commonlisp-vscode

** About e-graph

- https://egraphs-good.github.io/
- https://colab.research.google.com/drive/1tNOQijJqe5tw-Pk9iqd6HHb2abC5aRid?usp=sharing

* Libraries we might need in the future

** PROtocol and TESTcase manager

[[https://github.com/phoe/protest][phoe/protest]]

PROTEST is a tool for defining protocols and test cases written in and
for Common Lisp.

** Concrete Syntax Tree

https://github.com/s-expressionists/Concrete-Syntax-Tree
This library is intended to solve the problem of source tracking for
Common Lisp code.

** SICL

A fresh implementation of Common Lisp
https://github.com/robert-strandh/SICL

I'm sure there are tons of other user-case:
- infer types
- interpret code (symbolically or not)

* Scratch files

Pieces of code that could be useful

#+begin_src lisp
  (require 'bordeaux-threads)
  (bordeaux-threads:destroy-thread
   (let ((current-thread (bt:current-thread)))
     (find-if #'(lambda (thread)
		  (and (not (eq current-thread thread))
		       (string= "worker" (bt:thread-name thread))))
	      (sb-thread:list-all-threads))))
#+end_src

* Prior Arts

** Tinker (1980)
http://web.media.mit.edu/%7Elieber/Lieberary/Tinker/Tinker/Tinker.html

** Image Based develoment

[Image based development](https://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/ibcl/index.html)

** Code refactoring tools and libraries, linters, etc.

*** General

https://comby.dev/ (and https://github.com/s-kostyaev/comby.el)
https://github.com/reviewdog/reviewdog

*** common lisp

https://github.com/hyotang666/trivial-formatter
https://github.com/yitzchak/cl-indentify
https://github.com/vindarel/colisper (uses comby)
  - its catalog of rewrites: https://github.com/vindarel/colisper/tree/master/src/catalog/lisp
https://github.com/cxxxr/sblint
https://github.com/g000001/lisp-critic/
https://github.com/eschulte/lisp-format

*** javascript and front-end in general

https://github.com/facebookarchive/codemod replaced by
https://github.com/facebook/jscodeshift, which uses
https://github.com/benjamn/recast

Examples: https://github.com/cpojer/js-codemod

*** Ruby

https://github.com/whitequark/parser
https://github.com/seattlerb/ruby_parser
https://github.com/seattlerb/ruby2ruby/
https://docs.rubocop.org/rubocop-ast/node_pattern_compiler.html
https://nodepattern.herokuapp.com/
https://github.com/mbj/unparser

*** Other

Probably Rosely for C# and clang for C/C++. I'm sure there are tons of
tools/libraries for Java.

For python, there's the ast module, but I don't know if it can
preserve the formatting. There's a bunch of tools to format the code.

** Zulu.inuoe's attempt - clution

- https://github.com/Zulu-Inuoe/clution
- https://github.com/Zulu-Inuoe/clution.lib
- https://github.com/Zulu-Inuoe/lob

* Breeze on the internets

** Lisp project of the day

https://40ants.com/lisp-project-of-the-day/2020/08/0166-breeze.html

** Reddit

https://old.reddit.com/r/Common_Lisp/comments/pgtfm3/looking_for_feedbackhelp_on_a_project/

*** [[https://old.reddit.com/user/dzecniv][u/dzecniv]]

> testing features along with workers and a file watcher? Shouldn't
they be different projects?

    What annoys you when developing in lisp?

I find that setting up a test framework is more difficult than it
should be, so any effort on this area is appreciated. I mean: starting
with 5am is ok (but could be easier with an editor command), running
it from the CLI/a CI is less OK, getting the correct return code of
the tests needs more work, etc.

* To classify

https://quickdocs.org/cl-scripting
https://quickdocs.org/repl-utilities
[[https://github.com/slime/slime/issues/532][slime issue #532: Rename package and all the symbol prefixes]]
https://blog.cddr.org/posts/2021-11-23-on-new-ides/
https://common-lisp.net/project/slime/doc/html/Contributed-Packages.html

https://quickdocs.org/external-symbol-not-found
https://github.com/Bike/compiler-macro
https://quickdocs.org/dotenv

https://quickdocs.org/slite - SLIME based Test-runner for FiveAM tests
(and possibly others in the future)

* Discord

Discussion about =#:=
https://discord.com/channels/297478281278652417/569524818991644692/915330555334234192

* FAQ from newbies about common lisp

** What's the difference between load and require?

** What's asdf v. quicklisp v. packages v. "os packages"?

** The heck is RPLACA?

** What's the difference between =setf= and =setq=?

** Why use #:symbol (especially in =defpackage=)?

** Why start a file with =(cl:in-package #:cl-user)=?

** Why interactivity is important?

They don't actually ask that, they usually just don't think or know
about it.

Here's something that does an OK job at explaining the importance:
https://technotales.wordpress.com/2007/10/03/like-slime-for-vim/

** What's the difference between ~defvar~ and ~defparameter~?

** Something about using ~setf~ to create variables...

** When coming from another language

*** How to create a function-local variable?
